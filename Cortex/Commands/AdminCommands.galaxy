void libapex_command_ban(void testConds, void runActions)
{
	int player;
	unitgroup g;
	string val = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2 );
	player = libapex_color_to_player( val );
	if( player == -1 || PlayerType(player) != c_playerTypeUser) {
		return true;
	}

	if( !libapex_admin_haspermissions( EventPlayer(), player, libapex_admin_permissionlevel_moderator ) && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	else if(libapex_admin_getpermissions(EventPlayer()) < libapex_admin_getpermissions(player) || EventPlayer() == player) {
		return true;
	}
	
	GameOver( player, c_gameOverDefeat, false, true );
	g = UnitGroup( null, player, RegionEntireMap(), UnitFilter(0, 0, 0, 0), 0 );
	UnitGroupLoopBegin(g);
	while( !UnitGroupLoopDone() )
	{
		libapex_unitCache_remove(UnitGroupLoopCurrent());
		UnitRemove( UnitGroupLoopCurrent() );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	libapex_write_text(PlayerGroupAll(), libapex_colored_player_name(player) + StringToText(" has been banned by ") + libapex_colored_player_name(EventPlayer()));
	return true;
}

void libapex_command_disable(void testConds, void runActions)
{
	int player;
	string val = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2 );
	player = libapex_color_to_player( val );
	if( player == -1 || PlayerType(player) != c_playerTypeUser) {
		return true;
	}

	if( !libapex_admin_haspermissions( EventPlayer(), player, libapex_admin_permissionlevel_moderator ) && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	else if(libapex_admin_getpermissions(EventPlayer()) < libapex_admin_getpermissions(player) || EventPlayer() == player) {
		return true;
	}

	libapex_admin_disablecommands( player );
	
	libapex_write_text(PlayerGroupAll(), libapex_colored_player_name(player) + StringToText(" has had his commands disabled by ") + libapex_colored_player_name(EventPlayer()));
	return true;	
}

void libapex_command_enable(void testConds, void runActions)
{
	int player;
	string val = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2 );
	player = libapex_color_to_player( val );
	if( player == -1 || PlayerType(player) != c_playerTypeUser ) {
		return true;
	}

	if( !libapex_admin_haspermissions( EventPlayer(), player, libapex_admin_permissionlevel_moderator ) && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	else if(libapex_admin_getpermissions(EventPlayer()) < libapex_admin_getpermissions(player) || EventPlayer() == player) {
		return true;
	}

	libapex_admin_enablecommands( player );
	
	libapex_write_text(PlayerGroupAll(), libapex_colored_player_name(player) + StringToText(" has had his commands enabled by ") + libapex_colored_player_name(EventPlayer()));
	return true;	
}

void libapex_command_promote(void testConds, void runActions)
{
	int player;
	string val = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2 );
	player = libapex_color_to_player( val );
	if( player == -1 || PlayerType(player) != c_playerTypeUser) {
		return true;
	}

	if( !libapex_admin_haspermissions( EventPlayer(), player, libapex_admin_permissionlevel_admin ) && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	else if(libapex_admin_getpermissions(player) >= libapex_admin_permissionlevel_moderator) {
		return true;
	}
	
	libapex_admin_setpermission( player, libapex_admin_permissionlevel_moderator );
	
	libapex_write_text(PlayerGroupAll(), libapex_colored_player_name(player) + StringToText(" has been promoted to moderator by ") + libapex_colored_player_name(EventPlayer()));
	return true;	
}

void libapex_command_demote(void testConds, void runActions)
{
	int player;
	string val = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2 );
	player = libapex_color_to_player( val );
	if( player == -1 || PlayerType(player) != c_playerTypeUser) {
		return true;
	}

	if( !libapex_admin_haspermissions( EventPlayer(), player, libapex_admin_permissionlevel_admin ) && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	else if(libapex_admin_getpermissions(player) < libapex_admin_permissionlevel_moderator) {
		return true;
	}

	libapex_admin_setpermission( player, libapex_admin_permissionlevel_none );
	
	libapex_write_text(PlayerGroupAll(), libapex_colored_player_name(player) + StringToText(" has been demoted to user by ") + libapex_colored_player_name(EventPlayer()));
	return true;	
}

void libapex_command_adminremove(void testConds, void runActions)
{
	int player;
	unitgroup g;
	string val = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2 );
	player = libapex_color_to_player( val );
	if( player == -1 ) {
		return true;
	}

	if( !libapex_admin_haspermissions( EventPlayer(), player, libapex_admin_permissionlevel_moderator ) && EventPlayer() != player && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	else if(libapex_admin_getpermissions(EventPlayer()) < libapex_admin_permissionlevel_moderator && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	else if(libapex_admin_getpermissions(EventPlayer()) < libapex_admin_getpermissions(player)) {
		return true;
	}
	
	g = UnitGroup( null, player, RegionEntireMap(), UnitFilter(0, 0, 0, 0), 0 );
	UnitGroupLoopBegin(g);
	while( !UnitGroupLoopDone() )
	{
		if( UnitGetType( UnitGroupLoopCurrent() ) != libapex_getspawnertype() ) {
			libapex_unitCache_remove(UnitGroupLoopCurrent());
			UnitRemove( UnitGroupLoopCurrent() );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	
	libapex_write_text(PlayerGroupAll(), libapex_colored_player_name(player) + StringToText(" has been removed by ") + libapex_colored_player_name(EventPlayer()));
	return true;	
}

revealer[libapex_max_players] libapex_command_seeall_revealers;
void libapex_command_seeall(void testConds, void runActions)
{
	int i = 1;
	string state;
	void revealed;
	state = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2 );
	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_moderator && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}

	if( state == "off" ) { 
		while( i != libapex_max_players ) {
			if( libapex_command_seeall_revealers[i] ) {
				VisRevealerDestroy( libapex_command_seeall_revealers[i] );
				libapex_command_seeall_revealers[i] = null;
			}
			i = i + 1;
		}
		libapex_write_text(PlayerGroupAll(), StringToText("The map has been hidden by ") + libapex_colored_player_name(EventPlayer()) + StringToText("."));
	} else if( state == "on" ) {
		while( i != libapex_max_players ) {
			if( libapex_command_seeall_revealers[i] == null ) {
				libapex_command_seeall_revealers[i] = VisRevealerCreate( i, RegionEntireMap() );
			}
			i = i + 1;
		}
		libapex_write_text(PlayerGroupAll(), StringToText("The map has been revealed by ") + libapex_colored_player_name(EventPlayer()) + StringToText("."));
	} else {
		// toggle.
		while( i != libapex_max_players ) {
			if( libapex_command_seeall_revealers[i] == null ) {
				libapex_command_seeall_revealers[i] = VisRevealerCreate( i, RegionEntireMap() );
				revealed = true;
			} else {
				VisRevealerDestroy( libapex_command_seeall_revealers[i] );
				libapex_command_seeall_revealers[i] = null;
				revealed = false;
			}
			i = i + 1;
		}
		
		if( revealed ) {
			libapex_write_text(PlayerGroupAll(), StringToText("The map has been revealed by ") + libapex_colored_player_name(EventPlayer()) + StringToText("."));
		} else {
			libapex_write_text(PlayerGroupAll(), StringToText("The map has been hidden by ") + libapex_colored_player_name(EventPlayer()) + StringToText("."));
		}
	}
	return true;	
}


void libapex_command_smarthostile(void check, void run)
{
	string race;
	race = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2 );
	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_moderator && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	race = StringCase(race, false);

	if( race == "terran" ) { 
		libapex_ai_set_race(libapex_race_terran);
		libapex_write_text(PlayerGroupAll(), StringToText("Smart Hostile computer has been set to " + race + " by ") + libapex_colored_player_name(EventPlayer()) + StringToText("."));
	} else if( race == "zerg" ) {
		libapex_ai_set_race(libapex_race_zerg);
		libapex_write_text(PlayerGroupAll(), StringToText("Smart Hostile computer has been set to " + race + " by ") + libapex_colored_player_name(EventPlayer()) + StringToText("."));
	} else if( race == "protoss" ) {
		libapex_ai_set_race(libapex_race_protoss);
		libapex_write_text(PlayerGroupAll(), StringToText("Smart Hostile computer has been set to " + race + " by ") + libapex_colored_player_name(EventPlayer()) + StringToText("."));
	} else {
		libapex_write(PlayerGroupSingle(EventPlayer()), "<c val=\"ff0000\">Unable to change smarthostile race</c>: No valid race specified.");
	}
	return true;
}

void libapex_command_light(void testConds, void runActions)
{
	string light = StringWord(libapex_chat_get_parse_line(EventPlayer()), 2);
	fixed blendTime = StringToFixed(StringWord(EventChatMessage(false), 3));
	
	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_moderator  && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1)))
	{
		return true;
	}

	if(light == "")
	{
		light = GameTerrainSet();
	}
	
	light = libapex_param_catalog(c_gameCatalogLight, light);
	if(light == null)
	{
		libapex_write(PlayerGroupSingle(EventPlayer()), "<c val=\"ff0000\">Unable to change lighting</c>: No such light exists.");
		return true;
	}

	if(StringWord(libapex_chat_get_parse_line(EventPlayer()), 3) == "")
	{
		blendTime = 2;
	}

	GameSetLighting(light, blendTime);

	return true;
}

void libapex_command_fog(void testConds, void runActions)
{
	string state = StringWord(libapex_chat_get_parse_line(EventPlayer()), 2 );
	string paramOne;
	string paramTwo;
	string paramThree;
	fixed red;
	fixed green;
	fixed blue;

	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_moderator && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	
	paramOne = StringWord(libapex_chat_get_parse_line(EventPlayer()), 3);
	paramTwo = StringWord(libapex_chat_get_parse_line(EventPlayer()), 4);
	paramThree = StringWord(libapex_chat_get_parse_line(EventPlayer()), 5);

	if(state == "off")
	{ 
		FogSetEnabled(false);
	}
	else if(state == "on")
	{
		FogSetEnabled(true);
	}
	else if(state == "color")
	{
		red = libapex_boundsFixed(StringToFixed(paramOne), 0, 255) * 100 / 255;
		green = libapex_boundsFixed(StringToFixed(paramTwo), 0, 255) * 100 / 255;
		blue = libapex_boundsFixed(StringToFixed(paramThree), 0, 255) * 100 / 255;
		FogSetColor(Color(red, green, blue));
	}
	else if(state == "density")
	{
		FogSetDensity(StringToFixed(paramOne) / 100);
	}
	else if(state == "height")
	{
		FogSetStartHeight(StringToFixed(paramOne));
	}
	else if(state == "falloff")
	{
		FogSetFallOff(StringToFixed(paramOne) / 100);
	}
	else
	{
		libapex_write( PlayerGroupSingle(EventPlayer()), "Usage: !fog {on|off|color|density|height|falloff} [value]");
	}
	return true;
}

void libapex_command_creepspeed(void testConds, void runActions)
{ 
	string state;
	fixed speed;
	state = StringWord(libapex_chat_get_parse_line(EventPlayer()), 2);
	speed = StringToFixed(StringWord(libapex_chat_get_parse_line(EventPlayer()), 3));
	if( libapex_admin_getpermissions(EventPlayer()) < libapex_admin_permissionlevel_moderator && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1)))
	{
		return true;
	}

	if(speed >= 524287)
	{
	speed = 524287;
	}

	if( state == "growth" ) {
		CreepSetSpeed(c_creepSpeedGrowth, speed);
	} else if( state == "decay" ) {
		CreepSetSpeed(c_creepSpeedDecay, speed);
	} else if( state == "blend" ) {
		CreepSetSpeed(c_creepSpeedBlend, speed);
	} else {
		speed = StringToFixed(state);
		if(state == "")
		{
			libapex_write( PlayerGroupSingle(EventPlayer()), "Usage: !creepspeed [growth/decay/blend] <speed>");
			return true;
		}
		CreepSetSpeed(c_creepSpeedGrowth, speed);
		CreepSetSpeed(c_creepSpeedDecay, speed);
		CreepSetSpeed(c_creepSpeedBlend, speed);
	}
	libapex_write_text(PlayerGroupAll(),  StringToText("Creep speed has been set to ") +
		FixedToText(speed, 0) + StringToText(" by ") + libapex_colored_player_name(EventPlayer()));
	return true;	
}

void[libapex_max_players] libapex_command_trolls_used;

void libapex_command_trolls(void testConds, void runActions)
{
	playergroup p = PlayerGroupAll();
	unitgroup g;
	int i;
	int count;
	int curPlayer;
	text playerName;
	int flaggedUnits;
	void foundAny;
	void unitFlagged;
	string alert;
	string unitType;

	string weapon;
	string effect;
	fixed period;
	fixed range;
	int attacks;
	int damage;
	int penalty;
	int life;

	string behavior;
	int damageTemp;
	fixed damageMultiplier;
	int damageAddUnscaled;
	int damageAddScaled;
	fixed rangeBonus;
	fixed attackMultiplier;
	void isUnkillable;
	void isUntargetable;
	int lagCount;
	int creepMakers;

	string param = StringCase(StringWord(libapex_chat_get_parse_line
		(EventPlayer()), 2), false);

	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_moderator && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1)) ) {
		return true;
	}

	if(param == "off" || param == "disabled")
	{
		libapex_command_trolldetection[EventPlayer()] = false;
		libapex_write_success("Troll notifications are now disabled.");
		return true;
	}
	else if(param == "on" || param == "enabled")
	{
		libapex_command_trolldetection[EventPlayer()] = true;
		libapex_write_success("Troll notifications are now enabled.");
		return true;
	}
	
	PlayerGroupLoopBegin(p);
	while(!PlayerGroupLoopDone())
	{
		flaggedUnits = 0;
		lagCount = 0;
		creepMakers = 0;
		curPlayer = PlayerGroupLoopCurrent();
		playerName = libapex_colored_player_name(curPlayer) +
			libapex_color_text_by_player(curPlayer, StringToText(" (" +
			libapex_color_from_player(curPlayer) + ")"));
		g = UnitGroup(null, curPlayer, RegionEntireMap(),
			UnitFilter(0, 0, 0, 0), 0);

		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone())
		{
			unitFlagged = false;
			unitType = UnitGetType(UnitGroupLoopCurrent());

			// Checking the behaviors on the current unit
			damageMultiplier = 0;
			damageAddScaled = 0;
			damageAddUnscaled = 0;
			rangeBonus = 0;
			attackMultiplier = 1;
			penalty = 1;
			isUnkillable = false;
			isUntargetable = false;

			i = UnitBehaviorCountAll(UnitGroupLoopCurrent());
			while(i != 0 && !unitFlagged)
			{
				behavior = UnitBehaviorGet(UnitGroupLoopCurrent(), i);

				if(CatalogEntryScope(c_gameCatalogBehavior, behavior) == "CBehaviorBuff")
				{
					damageMultiplier = damageMultiplier + StringToFixed(CatalogFieldValueGet(
						c_gameCatalogBehavior, behavior, "Modification.DamageDealtFraction[1]",
						curPlayer)) * UnitBehaviorCount(UnitGroupLoopCurrent(), behavior);

					damageTemp = StringToInt(CatalogFieldValueGet(c_gameCatalogBehavior,
						behavior, "Modification.DamageDealtUnscaled[1]", curPlayer));
					damageAddUnscaled = damageAddUnscaled + damageTemp *
						UnitBehaviorCount(UnitGroupLoopCurrent(), behavior);
					
					damageTemp = StringToInt(CatalogFieldValueGet(c_gameCatalogBehavior,
						behavior, "Modification.DamageDealtScaled[1]", curPlayer));
					damageAddScaled = damageAddScaled + damageTemp *
						UnitBehaviorCount(UnitGroupLoopCurrent(), behavior);

					rangeBonus = rangeBonus + StringToFixed(CatalogFieldValueGet(c_gameCatalogBehavior,
						behavior, "Modification.WeaponRange", curPlayer)) *
						UnitBehaviorCount(UnitGroupLoopCurrent(), behavior);

					attackMultiplier = attackMultiplier * StringToFixed(CatalogFieldValueGet(c_gameCatalogBehavior,
						behavior, "Modification.AttackSpeedMultiplier", curPlayer)) *
						UnitBehaviorCount(UnitGroupLoopCurrent(), behavior);

					if(CatalogFieldValueGet(c_gameCatalogBehavior, behavior,
						"DamageResponse.ModifyFraction", curPlayer) == "0" &&
						CatalogFieldValueGet(c_gameCatalogBehavior, behavior,
						"DamageResponse.Chance", curPlayer) != "0" ||
						StringToFixed(CatalogFieldValueGet(c_gameCatalogBehavior,
						behavior, "DamageResponse.ClampMaximum", curPlayer)) <= 100 ||
						CatalogFieldValueGet(c_gameCatalogBehavior, behavior,
						"Modification.StateFlags[Invulnerable]", curPlayer) == "1")
					{
						isUnkillable = true;
					}
					if(CatalogFieldValueGet(c_gameCatalogBehavior, behavior,
						"Modification.StateFlags[NoDraw]", curPlayer) == "1" ||
						CatalogFieldValueGet(c_gameCatalogBehavior, behavior,
						"Modification.StateFlags[Untargetable]", curPlayer) == "1" ||
						CatalogFieldValueGet(c_gameCatalogBehavior, behavior,
						"Modification.StateFlags[Unselectable]", curPlayer) == "1")
					{
						isUntargetable = true;
					}
				}

				// Flag units based on their behaviors

				if(unitType != "Changeling" && behavior == "ChangelingDisguise")
				{
					unitFlagged = true;
					alert = " has a " + unitType + " with a ChangelingDisguise.";
					libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
				}

				if(unitType != "Hive" && unitType != "Lair" &&
					unitType != "Hatchery" && unitType != "CreepTumor" &&
					unitType != "CreepTumorBurrowed" &&
					(behavior == "makeCreep8x6" || behavior == "makeCreep4x4" ||
					behavior == "makeCreep3x3" || behavior == "makeCreep2x2"))
				{
					creepMakers = creepMakers + 1;
				}

				if(behavior == "SpawnLarva" && CreepIsPresent(PointWithOffset(
					UnitGetPosition(UnitGroupLoopCurrent()), 0, -3)) == false)
				{
					lagCount = lagCount + 1;
				}

				i = i - 1;
			}

			if(UnitTestPlane(UnitGroupLoopCurrent(), c_planeAir) == false &&
				UnitTestPlane(UnitGroupLoopCurrent(), c_planeGround) == false)
			{
				isUntargetable = true;
			}
			if(libNtve_gf_UnitIsInvulnerable(UnitGroupLoopCurrent()))
			{
				isUnkillable = true;
			}

			// Penalize units that aren't easily attacked.
			if(isUnkillable)
			{
				penalty = penalty * 2;
			}
			if(isUntargetable)
			{
				penalty = penalty * 2;
			}

			// Checking the weapons on the current unit.
			i = UnitWeaponCount(UnitGroupLoopCurrent());
			while(i != 0 && !unitFlagged)
			{
				weapon = UnitWeaponGet(UnitGroupLoopCurrent(), i);
				period = StringToFixed(CatalogFieldValueGet(c_gameCatalogWeapon, weapon, "Period", curPlayer));
				range = StringToFixed(CatalogFieldValueGet(c_gameCatalogWeapon, weapon, "Range", curPlayer));
				attacks = StringToInt(CatalogFieldValueGet(c_gameCatalogWeapon, weapon, "DisplayAttackCount", curPlayer));
				effect = CatalogFieldValueGet(c_gameCatalogWeapon, weapon, "DisplayEffect", curPlayer);
				damage = StringToInt(CatalogFieldValueGet(c_gameCatalogEffect, effect, "Amount", curPlayer));

				// Calculate the effective values of each, given the behaviors.
				if(attacks < 1)
				{
					attacks = 1;
				}

				if(damageMultiplier > 1)
				{
					if(damage + damageAddScaled >= 52427)
					{
						// Woah! Expert troll trying to make a numeric overflow!
						damage = damage / 25;
						damageAddScaled = damageAddScaled / 25;
						damage = (FixedToInt(IntToFixed(damage + damageAddScaled) *
							(damageMultiplier + 1)) + damageAddUnscaled) * attacks;
						damage = damage * 25;
					}
					else
					{
						damage = (FixedToInt(IntToFixed(damage + damageAddScaled) *
							(damageMultiplier + 1)) + damageAddUnscaled) * attacks;
					}
				}
				else
				{
					damage = (FixedToInt(IntToFixed(damage + damageAddScaled) *
						(damageMultiplier + 1)) + damageAddUnscaled) * attacks;
				}
				
				if(attackMultiplier == 0)
				{
					attackMultiplier = 1;
				}

				period = period * attackMultiplier;
				if(period <= 0.0333)
				{
					period = 0.0333;
				}
				period = 1 / period;

				range = range + rangeBonus;

				// Categorize the unit's threat level based on its damage capabilities.
				if(damage * FixedToInt(period) * penalty >= 1000)
				{
					unitFlagged = true;
					alert = " has a ";
					if(isUnkillable)
					{
						alert = alert + "unkillable ";
					}
					if(isUntargetable)
					{
						if(isUnkillable)
						{
							alert = alert + "and ";
						}
						alert = alert + "untargetable ";
					}
					alert = alert + unitType + " which does " + IntToString(damage * FixedToInt(period)) + " damage per second.";
					libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
				}
				else if(damage * penalty >= 1000)
				{
					unitFlagged = true;
					alert = " has a ";
					if(isUnkillable)
					{
						alert = alert + "unkillable ";
					}
					if(isUntargetable)
					{
						if(isUnkillable)
						{
							alert = alert + "and ";
						}
						alert = alert + "untargetable ";
					}
					alert = alert + unitType + " which does " + IntToString(damage) + " damage.";
					libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
				}
				else if(range >= 50)
				{
					unitFlagged = true;
					alert = " has a ";
					if(isUnkillable)
					{
						alert = alert + "unkillable ";
					}
					if(isUntargetable)
					{
						if(isUnkillable)
						{
							alert = alert + "and ";
						}
						alert = alert + "untargetable ";
					}
					alert = alert + unitType + " with " +	FixedToString(range, 1) + " range.";
					libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
				}

				// Categorize the unit's threat level based on its health
				life = FixedToInt(UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropLifeMax, c_unitPropCurrent)) +
					FixedToInt(UnitGetPropertyFixed(UnitGroupLoopCurrent(), c_unitPropShields, c_unitPropCurrent));
				if(life * penalty >= 100000)
				{
					unitFlagged = true;
					alert = " has a ";
					if(isUnkillable)
					{
						alert = alert + "unkillable ";
					}
					if(isUntargetable)
					{
						if(isUnkillable)
						{
							alert = alert + "and ";
						}
						alert = alert + "untargetable ";
					}
					alert = alert + unitType + " with " + IntToString(life) + " total health.";
					libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
				}

				// Categorize the unit's threat level based on its height
				if(!unitFlagged && UnitGetHeight(UnitGroupLoopCurrent()) >= 25)
				{
					unitFlagged = true;
					alert = " has a ";
					if(isUnkillable)
					{
						alert = alert + "unkillable ";
					}
					if(isUntargetable)
					{
						if(isUnkillable)
						{
							alert = alert + "and ";
						}
						alert = alert + "untargetable ";
					}
					alert = alert + unitType + " with " + FixedToString(UnitGetHeight(UnitGroupLoopCurrent()), 1) + " height.";
					libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
				}

				i = i - 1;
			}

			// Categorize the unit based on its visibility and type using a blacklist.
			if(!unitFlagged && libNtve_gf_UnitIsVisibleToPlayer(UnitGroupLoopCurrent(), EventPlayer()) == false)
			{
				// List units here that only 1 would be needed to troll.
				// Only the abilities of each unit need to be considered.
				if(unitType == "Hyperion" ||
					unitType == "Purifier" ||
					unitType == "Artanis" ||
					unitType == "Mothership" ||
					unitType == "TestHero" ||
					unitType == "Artifact")
				{
					unitFlagged = true;
					alert = " has a ";
					if(isUnkillable)
					{
						alert = alert + "unkillable ";
					}
					if(isUntargetable)
					{
						if(isUnkillable)
						{
							alert = alert + "and ";
						}
						alert = alert + "untargetable ";
					}
					alert = alert + unitType + " that is not visible.";
					libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
				}
			}

			// Categorize the unit based on ability combinations
			if(!unitFlagged && damageAddScaled + damageAddUnscaled > 0 &&
				(unitType == "Purifier" ||
				unitType == "Artanis" ||
				unitType == "Mothership"))
			{
				unitFlagged = true;
				alert = " has a ";
				if(isUnkillable)
				{
					alert = alert + "unkillable ";
				}
				if(isUntargetable)
				{
					if(isUnkillable)
					{
						alert = alert + "and ";
					}
					alert = alert + "untargetable ";
				}
				alert = alert + unitType + " with a lethal vortex.";
				libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
			}

			if(unitFlagged)
			{
				flaggedUnits = flaggedUnits + 1;
			}

			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();

		// Search for massed units. Sensitivity is increased for large units.
		i = CatalogEntryCount(c_gameCatalogUnit);
		while(i != 0)
		{
			unitType = CatalogEntryGet(c_gameCatalogUnit, i);
			count = TechTreeUnitCount(curPlayer, unitType, c_techCountQueuedOrBetter);

			if(count == 0)
			{
				// Optimization; stops checking the other if's because they
				// can never be true.
			}
			else if(count >= 72)
			{
				alert = " has " + IntToString(count) + " " + unitType + " units.";
				libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
			}
			else if(count >= 24 && StringToFixed(CatalogFieldValueGet(
				c_gameCatalogUnit, unitType, "ScoreMake", curPlayer)) >= 500)
			{
				alert = " has " + IntToString(count) + " " + unitType + " units.";
				libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
			}
			else if(count >= 12 && StringToFixed(CatalogFieldValueGet(
				c_gameCatalogUnit, unitType, "ScoreMake", curPlayer)) >= 1000)
			{
				alert = " has " + IntToString(count) + " " + unitType + " units.";
				libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
			}
			else if(count >= 8 && (unitType == "Hyperion" ||
				unitType == "DrakkenLaserDrill" ||
				unitType == "Artanis" ||
				unitType == "Purifier" ||
				unitType == "Artifact" ||
				unitType == "TestHero" ||
				unitType == "Odin" ||
				unitType == "Kerrigan" ||
				unitType == "KerriganChar" ||
				unitType == "BattlecruiserHelios" ||
				unitType == "Loki" ||
				unitType == "WreckedBattlecruiserHeliosFinal" ||
				unitType == "Selendis" ||
				unitType == "Mohandar" ||
				unitType == "VoidSeeker" ||
				unitType == "Blocker16x16" ||
				unitType == "Blocker8x8" ||
				unitType == "Blocker4x4" ||
				unitType == "SpacePlatformDestructibleJumboBlocker" ||
				unitType == "SpacePlatformDestructibleLargeBlocker" ||
				unitType == "SpacePlatformDestructibleMediumBlocker" ||
				unitType == "SporeCannon" ||
				unitType == "Tosh" ||
				unitType == "Nova" ||
				unitType == "GhostAcademy" ||
				unitType == "Nuke" ||
				unitType == "HeroNuke" ||
				unitType == "SpectreNuke" ||
				unitType == "RepulserField12" ||
				unitType == "RepulserField10" ||
				unitType == "RepulserField8" ||
				unitType == "RepulserField6" ||
				unitType == "WallOfFire"
				))
			{
				alert = " has " + IntToString(count) + " " + unitType + " units.";
				libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
			}

			i = i - 1;
		}

		if(lagCount >= 2)
		{
			alert = " has " + IntToString(lagCount) + " units that create lag.";
			libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
		}

		if(flaggedUnits >= 10)
		{
			alert = " has " + IntToString(flaggedUnits) + " questionable units.";
			libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
		}

		if(creepMakers >= 20)
		{
			alert = " has " + IntToString(creepMakers) + " units that make creep.";
			libapex_write_text(PlayerGroupSingle(EventPlayer()), playerName + StringToText(alert));
		}

		if(flaggedUnits > 0)
		{
			foundAny = true;
		}

		PlayerGroupLoopStep();
	}
	PlayerGroupLoopEnd();

	if(foundAny == false)
	{
		if(libapex_command_trolls_used[EventPlayer()] == false)
		{
			HelpPanelAddTip(PlayerGroupSingle(EventPlayer()),
				StringToText("!trolls command"),
				StringToText("The <h>!trolls</h> command quickly searches the entire map for units that " +
				"many players could find distracting. It checks for units that deal way excessive " +
				"damage or have excessive range. It also checks for units that are extremely high, " +
				"or are massed in excess. It also checks for combinations of behaviors that are " +
				"known to achieve the same effect.<n/><n/>Additionally, there is a real time notification " +
				"system that can be enabled using <h>!trolls on</h> and disabled by <h>!trolls off</h>. " +
				"It is enabled for hosts and moderators only."),
				StringToText("The !trolls command"),
				"Assets\\Textures\\btn-ability-terran-nuclearstrike-color.dds");
			libapex_command_trolls_used[EventPlayer()] = true;
		}
		libapex_write(PlayerGroupSingle(EventPlayer()), "No threatening units were found.");
	}

	return true;
}

void libapex_command_log(void checkConds, void runActions)
{
	int plr = -1;
	string val = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2 );
	plr = libapex_color_to_player( val );
	
	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_moderator && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	
	if( plr != -1 )
	{
		libapex_write_text(PlayerGroupSingle(EventPlayer()), libapex_log_getlog(plr));
	} else {
		libapex_write_text(PlayerGroupSingle(EventPlayer()), libapex_log_getgloballog());
	}
	return true;
}

void libapex_command_secure(void checkConds, void runActions)
{
	string onoff = "ON";
	string params = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2);
	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_admin && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1))) {
		return true;
	}
	
	if(params == "on") {
		libapex_secure_mode = true;
	} else if( params == "off") {
		libapex_secure_mode = false;
	} else {
		libapex_secure_mode = !libapex_secure_mode;
	}
	
	if( !libapex_secure_mode ) {
		onoff = "OFF";
	}
	
	libapex_write(PlayerGroupSingle(EventPlayer()), "Cortex Secure Mode is now " + onoff + ". When Secure Mode is disabled, players can use potentially dangerous commands that can disrupt gameplay easily and without warning. Only disable secure mode with players you trust, or promote those whom you do trust.");
	return true;
}
void libapex_command_setting(void checkConds, void runActions)
{
	string setting = StringWord( libapex_chat_get_parse_line(EventPlayer()), 2);
	fixed val;
	const string settingList = "maxspawncount||maxspawnrate||spawnperiod||spawntimeout||minscale||maxscale";
	
	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_admin && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1)) ) {
		return true;
	}
	
	if(StringWord( libapex_chat_get_parse_line(EventPlayer()), 2) == "") {
		libapex_write(PlayerGroupSingle(EventPlayer()), "Usage:");
		libapex_write(PlayerGroupSingle(EventPlayer()), "!setting " + settingList + " val");
		libapex_write(PlayerGroupSingle(EventPlayer()), "To list current settings: !setting list");
		return true;
	}
	if(StringEqual(StringWord( libapex_chat_get_parse_line(EventPlayer()), 2), "list", false)) {
		libapex_write(PlayerGroupSingle(EventPlayer()), "maxspawncount: " + IntToString(libapex_setting_getint(libapex_setting_int_maxspawncount)));
		libapex_write(PlayerGroupSingle(EventPlayer()), "maxspawnrate (#/spawnperiod): " + IntToString(libapex_setting_getint(libapex_setting_int_maxspawnrate)));
		libapex_write(PlayerGroupSingle(EventPlayer()), "spawnperiod (in seconds): " + IntToString(libapex_setting_getint(libapex_setting_int_spawnperiod)));
		libapex_write(PlayerGroupSingle(EventPlayer()), "spawntimeout: " + IntToString(libapex_setting_getint(libapex_setting_int_spawntimeout)));
		libapex_write(PlayerGroupSingle(EventPlayer()), "minscale: " + FixedToString(libapex_setting_getfixed(libapex_setting_fixed_minscale), c_fixedPrecisionAny));
		libapex_write(PlayerGroupSingle(EventPlayer()), "maxscale: " + FixedToString(libapex_setting_getfixed(libapex_setting_fixed_maxscale), c_fixedPrecisionAny));
		return true;
	}
	
	if(StringEqual(setting, "maxspawncount", false)) {
		if(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3) == "" || StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3)) <= 0) {
			val = 24;
		}
		else {
			val = StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3));
		}
		
		if(val > IntToFixed(libapex_setting_getint(libapex_setting_int_maxspawnrate))) {
			libapex_write_error("maxspawncount cannot be greater than maxspawnrate");
			return true;
		}
		
		libapex_setting_setint(libapex_setting_int_maxspawncount, FixedToInt(val));
		libapex_write_success(StringCase(setting, false) + " set to " + FixedToString(val, 0));
		return true;
	}
	if(StringEqual(setting, "maxspawnrate", false)) {
		if(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3) == "" || StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3)) <= 0) {
			val = 100;
		}
		else {
			val = StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3));
		}
		
		if(val < IntToFixed(libapex_setting_getint(libapex_setting_int_maxspawncount))) {
			libapex_write_error("maxspawnrate cannot be less than maxspawncount");
			return true;
		}
		
		libapex_setting_setint(libapex_setting_int_maxspawnrate, FixedToInt(val));
		libapex_write_success(StringCase(setting, false) + " set to " + FixedToString(val, 0));
		return true;
	}
	if(StringEqual(setting, "spawnperiod", false)) {
		if(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3) == "" || StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3)) <= 0) {
			val = 60;
		}
		else {
			val = StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3));
		}
		libapex_setting_setint(libapex_setting_int_spawnperiod, FixedToInt(val));
		libapex_write_success(StringCase(setting, false) + " set to " + FixedToString(val, 0));
		return true;
	}
	if(StringEqual(setting, "spawntimeout", false)) {
		if(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3) == "" || StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3)) <= 0) {
			val = 30;
		}
		else {
			val = StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3));
		}
		libapex_setting_setint(libapex_setting_int_spawntimeout, FixedToInt(val));
		libapex_write_success(StringCase(setting, false) + " set to " + FixedToString(val, 0));
		return true;
	}
	if(StringEqual(setting, "minscale", false)) {
		if(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3) == "" || StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3)) <= 0) {
			val = 0.05;
		}
		else {
			val = StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3));
		}
		
		if(val > libapex_setting_getfixed(libapex_setting_fixed_maxscale)) {
			libapex_write_error("minscale cannot be greater than maxscale");
			return true;
		}
		
		libapex_setting_setfixed(libapex_setting_fixed_minscale, val);
		libapex_write_success(StringCase(setting, false) + " set to " + FixedToString(val, 4));	
		return true;
	}
	if(StringEqual(setting, "maxscale", false)) {
		if(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3) == "" || StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3)) <= 0) {
			val = 10.0;
		}
		else {
			val = StringToFixed(StringWord( libapex_chat_get_parse_line(EventPlayer()), 3));
		}
		
		if(val < libapex_setting_getfixed(libapex_setting_fixed_minscale)) {
			libapex_write_error("maxscale cannot be less than minscale");
			return true;
		}
		
		libapex_setting_setfixed(libapex_setting_fixed_maxscale, val);
		libapex_write_success(StringCase(setting, false) + " set to " + FixedToString(val, 4));
		return true;
	}
	
	return true;
}
void libapex_command_fruit(void testConds, void runActions)
{
	int count;
	string amsgFruit;
	const string fruits = "Apple Banana Cherry Grape Lemon Orange Pear Pineapple Strawberry Watermelon WatermelonSmall";
	
	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_admin && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1)) ) {
		return true;
	}
	
	if(StringEqual(StringWord(libapex_chat_get_parse_line(EventPlayer()), 2), "remove", false)) {
		libNtve_gf_SendActorMessageToGameRegionWithFilters(RegionEntireMap(), c_actorIntersectAgainstCenter, "Destroy", "Model", "IsStatus isFruit 1");
		return true;
	}
	
	if(StringWord(libapex_chat_get_parse_line(EventPlayer()), 2) == "") {
		count = 500;
	}
	else {
		count = StringToInt(StringWord(libapex_chat_get_parse_line(EventPlayer()), 2));
	}
	while(count > 0) {
		amsgFruit = StringWord(fruits, RandomInt(1, 11));
		libNtve_gf_CreateModelAtPoint("Shape" + amsgFruit, RegionRandomPoint(RegionEntireMap()));
		ActorSend(libNtve_gf_ActorLastCreated(), "SetScale " + FixedToString(RandomFixed(.8, 2.5), 4));
		ActorSend(libNtve_gf_ActorLastCreated(), "SetFacing " + FixedToString(RandomFixed(0, 360), 4));
		ActorSend(libNtve_gf_ActorLastCreated(), "StatusSet isFruit 1");
		count -= 1;
	}
	
	libapex_write(PlayerGroupSingle(EventPlayer()), "Type !fruit remove to be less fruity.");
	
	return true;
}
void libapex_command_xml(void testConds, void runActions)
{
	string param = StringWord(libapex_chat_get_parse_line(EventPlayer()), 2);
	
	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_admin && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1)) ) {
		return true;
	}
	
	if(StringEqual(param, "on", false)) {
		libapex_setting_use_xml = true;
		libapex_write(PlayerGroupSingle(EventPlayer()), "XML chat codes have been turned on");
		return true;
	}
	else if(StringEqual(param, "off", false)) {
		libapex_setting_use_xml = false;
		libapex_write(PlayerGroupSingle(EventPlayer()), "XML chat codes have been turned off");
		return true;
	}
	else if(StringEqual(param, "", false)) {
		if(libapex_setting_use_xml) {
			libapex_setting_use_xml = false;
			libapex_write(PlayerGroupSingle(EventPlayer()), "XML chat codes have been turned off");
			return true;
		}
		else {
			libapex_setting_use_xml = true;
			libapex_write(PlayerGroupSingle(EventPlayer()), "XML chat codes have been turned on");
			return true;
		}
	}
	
	libapex_write(PlayerGroupSingle(EventPlayer()), "Type \"!xml on|off\" to turn XML coding on or off, or just type \"!xml\" to toggle it.");
	return true;
}
string libapex_soundtrack_music_current = "(default)";
string libapex_soundtrack_ambience_current = "(default)";
void libapex_command_soundtrack(void testConds, void runActions) //!soundtrack [name] [ambience|music]
{
	string soundtrack;
	string option;
	
	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_moderator && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1)) ) {
		return true;
	}
	
	if(StringWord(libapex_chat_get_parse_line(EventPlayer()), 2) != "") {
		soundtrack = StringWord(libapex_chat_get_parse_line(EventPlayer()), 2);
	}
	else {
		libapex_write(PlayerGroupSingle(EventPlayer()), "Current soundtrack: " + libapex_soundtrack_music_current + " | Current ambience: " + libapex_soundtrack_ambience_current);
		libapex_write(PlayerGroupSingle(EventPlayer()), "Syntax is !soundtrack [name] [\"ambience\" or \"music\" (default)] or !soundtrack stop [\"ambience\" or \"music\" (default)]");
		return true;
	}
	
	if(StringEqual(soundtrack, "reset", c_stringNoCase) || StringEqual(soundtrack, "stop", c_stringNoCase)) {
		if(StringEqual(StringWord(libapex_chat_get_parse_line(EventPlayer()), 3), "ambience", c_stringNoCase)) {
			SoundtrackStop(PlayerGroupAll(), c_soundtrackCategoryAmbience, true);
			libapex_soundtrack_ambience_current = "none";
			libapex_write(PlayerGroupSingle(EventPlayer()), "Ambience soundtrack stopped");
		}
		else {
			SoundtrackStop(PlayerGroupAll(), c_soundtrackCategoryMusic, true);
			libapex_soundtrack_music_current = "none";
			libapex_write(PlayerGroupSingle(EventPlayer()), "Music soundtrack stopped");
		}
		return true;
	}

	soundtrack = libapex_param_catalog(c_gameCatalogSoundtrack, soundtrack);
	if(soundtrack == null) {
		libapex_write(PlayerGroupSingle(EventPlayer()), "<c val=\"ff0000\">Unable to play soundtrack</c>: No such soundtrack exists.");
		return true;
	}

	if(StringEqual(StringWord(libapex_chat_get_parse_line(EventPlayer()), 3), "ambience", c_stringNoCase)) {
		SoundtrackStop(PlayerGroupAll(), c_soundtrackCategoryAmbience, true);
		SoundtrackPlay(PlayerGroupAll(), c_soundtrackCategoryAmbience, soundtrack, c_soundtrackCueAny, c_soundtrackIndexAny, true);
		libapex_soundtrack_ambience_current = soundtrack;
		libapex_write(PlayerGroupSingle(EventPlayer()), "Playing soundtrack: " + soundtrack);
	}
	else {
		SoundtrackStop(PlayerGroupAll(), c_soundtrackCategoryMusic, true);
		SoundtrackPlay(PlayerGroupAll(), c_soundtrackCategoryMusic, soundtrack, c_soundtrackCueAny, c_soundtrackIndexAny, true);
		libapex_soundtrack_music_current = soundtrack;
		libapex_write(PlayerGroupSingle(EventPlayer()), "Playing soundtrack: " + soundtrack);	
	}

	return true;
}
void libapex_command_weather(void testConds, void runActions) //!weather off|rain|snow|hail|fog|mist|sandstorm|sun [density] [intensity (HDR)] #region
{
	int count;
	int i;
	string weather = StringWord(libapex_chat_get_parse_line(EventPlayer()), 2);
	string density = StringWord(libapex_chat_get_parse_line(EventPlayer()), 3);
	string HDR = StringWord(libapex_chat_get_parse_line(EventPlayer()), 4);
	string rgnName;
	region rgn;
	const string weather_types = "rain snow hail fog mist sandstorm sun";
	const string weather_model = "RainEmitterLarge Snow SnowLight WindEmitterBrownMedium FogMist WindRough Sunrays";
	
	if( libapex_admin_getpermissions( EventPlayer() ) < libapex_admin_permissionlevel_moderator && !libapex_command_allowed(EventPlayer(), StringWord(libapex_chat_get_parse_line(EventPlayer()), 1)) ) {
		return true;
	}
	
	if(weather == "") {
		libapex_write(PlayerGroupSingle(EventPlayer()), "Usage: !weather rain|snow|hail|fog|mist|sandstorm|sun [amount (default: 25)] [HDR] #[region]");
		return true;
	}
	
	else if(weather == "off") {
		rgnName = StringWord(libapex_chat_get_parse_line(EventPlayer()), 3); //if turning weather off, region is 2nd param
		if(StringSub(rgnName, 1, 1) != "#") {
			rgn = RegionEntireMap();
		}
		else {
			rgnName = StringSub(rgnName, 2, StringLength(rgnName));
			if(DataTableValueExists(true, libapex_command_region_buildidentifier(rgnName) + "_link"))
			{
				rgn = DataTableGetRegion(true, libapex_command_region_buildidentifier(rgnName) + "_link");
			}
			else
			{
				rgn = DataTableGetRegion(true, rgnName);
			}

			if(rgn == null)
			{
				libapex_write_error("No region with that name exists!");
				return true;
			}
		}
		
		libNtve_gf_SendActorMessageToGameRegionWithFilters(rgn, c_actorIntersectAgainstCenter, "SetOpacity {0} {2}", "Model", "IsStatus isWeather 1");
		Wait(2, c_timeGame);
		libNtve_gf_SendActorMessageToGameRegionWithFilters(rgn, c_actorIntersectAgainstCenter, "Destroy", "Model", "IsStatus isWeather 1");
				
		return true;
	}
	
	rgnName = StringWord(libapex_chat_get_parse_line(EventPlayer()), 5);
	
	//search the string for the right weather
	i = 1;
	while(StringWord(weather_types, i) != "") {
		if(StringEqual(weather, StringWord(weather_types, i), c_stringNoCase)) {
			weather = StringWord(weather_model, i);
			break;
		}
		i += 1;
	}
	if(StringWord(weather_types, i) == "") {
			libapex_write_error("Invalid weather type: valid types are " + weather_types);
			return true;		
	}
	
	//get density
	if(density == "" || StringToInt(density) == 0) {
		count = 25;
	}
	else {
		count = StringToInt(density);
	}
	
	//check intensity (HDR)
	if(HDR == "") {
		HDR = "1";
	}
	else if(StringToFixed(HDR) == 0) {
		HDR = ".001";
	}
	
	
	//get region
	if(StringSub(rgnName, 1, 1) != "#") {
		rgn = RegionEntireMap();
	}
	else {
		rgnName = StringSub(rgnName, 2, StringLength(rgnName));
		if(DataTableValueExists(true, libapex_command_region_buildidentifier(rgnName) + "_link"))
		{
			rgn = DataTableGetRegion(true, libapex_command_region_buildidentifier(rgnName) + "_link");
		}
		else
		{
			rgn = DataTableGetRegion(true, libapex_command_region_buildidentifier(rgnName));
		}

		if(rgn == null)
		{
			libapex_write_error("No region with that name exists!");
			return true;
		}
	}

	//first turn off weather in region

	libNtve_gf_SendActorMessageToGameRegionWithFilters(rgn, c_actorIntersectAgainstCenter, "SetOpacity {0} {2}", "Model", "IsStatus isWeather 1");
	Wait(2, c_timeGame);
	libNtve_gf_SendActorMessageToGameRegionWithFilters(rgn, c_actorIntersectAgainstCenter, "Destroy", "Model", "IsStatus isWeather 1");

	
	//create weather at random points in region
	while(count > 0) {
		libNtve_gf_CreateModelAtPoint(weather, RegionRandomPoint(rgn));
		ActorSend(libNtve_gf_ActorLastCreated(), "SetScale " + FixedToString(RandomFixed(.8, 1.2), 2));
		ActorSend(libNtve_gf_ActorLastCreated(), "SetTintColor {250,250,250 " + HDR + "}");
		ActorSend(libNtve_gf_ActorLastCreated(), "SetFacing 45");
		ActorSend(libNtve_gf_ActorLastCreated(), "StatusSet isWeather 1");	
		count -= 1;
	}
	

	return true;
}
void libapex_command_mapbounds(void testConds, void runActions) 
{
	region rgn;
	string rgnName = StringWord(libapex_chat_get_parse_line(EventPlayer()), 2);
	
	if(rgnName == "" || StringEqual(rgnName, "reset", c_stringNoCase) ) { //reset bounds to default
		RegionPlayableMapSet(RegionEntireMap());
		CameraSetBounds(PlayerGroupAll(), RegionPlayableMap(), true);		
		libapex_write_text(PlayerGroupAll(), StringToText("Map bounds set to default by ") + libapex_colored_player_name(EventPlayer()));
		return true;
	}
	else if(StringSub(rgnName, 1, 1) != "#") {
		libapex_write_error("Invalid region. Please enter region as #_____, so region \"home\" would be #home");		
		return true;
	}
	else {
		rgnName = StringSub(rgnName, 2, StringLength(rgnName));
		if(DataTableValueExists(true, libapex_command_region_buildidentifier(rgnName) + "_link"))
		{
			rgn = DataTableGetRegion(true, libapex_command_region_buildidentifier(rgnName) + "_link");
		}
		else
		{
			rgn = DataTableGetRegion(true, libapex_command_region_buildidentifier(rgnName));
		}
		if(rgn == null)
		{
			libapex_write_error("No region with that name exists!");
			return true;
		}
	}
	
    RegionPlayableMapSet(rgn);
    CameraSetBounds(PlayerGroupAll(), rgn, true);
	libapex_write_success("Map bounds set to region \"" + rgnName + "\"");
	libapex_write_text(PlayerGroupAll(), StringToText("Map bounds set by ") + libapex_colored_player_name(EventPlayer()));
	libapex_write(PlayerGroupAll(), "Map bounds can be set to default with \"!mapbounds reset\"");
	return true;
}
